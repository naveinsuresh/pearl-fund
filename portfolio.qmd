---
title: "Portfolio Optimization"
author: "Navein Suresh, Suryaveer Singh"
date: Sys.date()
format: html
editor: visual
---

## Overview

Our objective in this project is to optimize a portfolio of stocks for risk-adjusted returns. We will be focusing on a 5-stock portfolio, nicknamed the — [***Pearl Fund***]{.underline}. It consists of the leading semiconductor companies in the market:

1.  *Advanced Micro Device, Inc. (NASDAQ: AMD)*
2.  *Intel Corp. (NASDAQ: INTC)*
3.  *NVIDIA Corp. (NASDAQ: NVDA)*
4.  *QUALCOMM Inc. (NASDAQ: QCOM)*
5.  *Taiwan Semiconductor Mfg. Co. Ltd. (NYSE: TSM)*

We make use of various financial models, which we go into depth later on while also leverage the tidyquant package on R as our convenient tool for portfolio optimization. Using historical data, we will test our portfolio’s performance and compare it to the performance of two benchmark index funds — S&P 500 and NASDAQ.

Be sure to have to following libraries installed and imported before proceeding:

```{r}
library(tidyquant)
library(tidyverse)
library(ggplot2)
library(knitr)
```

Our testing time period will be from January 1, 2004 to January 1, 2024. This allows us to account for a range of economic situations — most notably the global financial crisis of 2008 and the SARS COVID-19 epidemic of 2020.

We begin with an equally weighted portfolio of the above stocks, each at 20% equity holding. For capital consideration, we will assume we start with \$10,000 (USD). You will also find us retrieving the recent 10-year treasury yields using the tidyquant functions.

```{r}
stock_tickers <- c("AMD", "INTC", "NVDA", "QCOM", "TSM")
weights1 <- rep(0.2, 5)
weights2 = c(0.15, 0.1, 0.4, 0.25, 0.1)
initial_investment <- 10000

# Initial Portfolio (YAHOO)
stock_allocations <- weights1 * initial_investment
portfolio <- data.frame("Equity" = stock_tickers, "Investment ($)" = stock_allocations)

# Treasury Yields (FRED)
ten_year_treasury_yield_table = arrange(tq_get("DGS10", get = "economic.data"), desc(date))
latest_ten_year_treasury_yield = slice(ten_year_treasury_yield_table, 1)$price

print(portfolio)
cat("Latest 10-year Treasury Yield: ",latest_ten_year_treasury_yield,"%")
```

Next, we turn to assembling our aggregation for our tech portfolio using historical returns for our specified time ranged mentioned earlier (segmented by monthly returns).

```{r}

# Raw Stock Monthly Returns
stock_returns_monthly_raw <- tq_get(stock_tickers, get  = "stock.prices", from = "2004-01-01", to   = "2024-01-01")

# Transformed Monthly Stock Returns
stock_returns_monthly = stock_returns_monthly_raw %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturns")

stock_returns_monthly
```

Below is a graph of the monthly closing prices for our tech portfolio stocks from Jan. 01, 2004 to Jan 01, 2024. We have standardized the data to allow for proper time series analysis.

```{r}
stock_returns_monthly_raw %>% group_by(symbol) %>% mutate(close = 100*(close - first(close))/first(close)) %>% ggplot(aes(date, close, color=symbol)) + geom_line()
```

You can also find the monthly returns under the same timeline for our stock selections. The more volatile stock returns can be seen with the graphs displaying more a jagged, spread out appearance.

```{r}
stock_returns_monthly %>% ggplot(aes(date, `MonthlyReturns`, color=symbol)) + 
  geom_line() +
  facet_wrap(~ symbol)
```

Once we have our monthly historical stock returns for our time frame, we move to our two benchmark index funds, which we use as a comparison for our portfolio performance, *SPDR S&P 500 ETF Trust (NYSE: SPY) & NASDAQ COMPOSITE (NYSE: QQQ).* We pull the respective historical monthly returns once again for these two benchmarks.

**S&P 500:**

```{r}

# Raw S&P 500 Monthly Returns
spy_returns_monthly_raw <- tq_get("SPY", get = "stock.prices", from = "2004-01-01", to = "2024-01-01")

# Transformed S&P 500 Monthly Returns
spy_returns_monthly = tq_transmute(spy_returns_monthly_raw, select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "SPYMonthlyReturns")

### Transforms data into percentages ###
spy_returns_monthly_percentages = data.frame("date" = spy_returns_monthly$date, "SPYPercentReturns" = spy_returns_monthly$SPYMonthlyReturns * 100)


spy_returns_monthly
spy_returns_monthly_percentages
```

**NASDAQ:**

```{r}

# Raw NASDAQ Monthly Returns
nasdaq_returns_monthly_raw <- tq_get("QQQ", get = "stock.prices", from = "2004-01-01", to = "2024-01-01")

# Transformed NASDAQ Monthly Returns
nasdaq_returns_monthly = tq_transmute(nasdaq_returns_monthly_raw, select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "NASDAQMonthlyReturns")

### Transforms data into percentages ###
nasdaq_returns_monthly_percentages = data.frame("date" = nasdaq_returns_monthly$date, "NASDAQPercentReturns" = nasdaq_returns_monthly$NASDAQMonthlyReturns * 100)

nasdaq_returns_monthly
nasdaq_returns_monthly_percentages
```

The following line graph depicts the price trends for both the benchmark returns — SPY (light blue) & QQQ (orange). Once again we standardize the index prices for a better comparison.

```{r}
# Combining benchmark raw dataframes
benchmark_returns_raw = rbind(spy_returns_monthly_raw, nasdaq_returns_monthly_raw)

benchmark_returns_raw %>% group_by(symbol) %>% mutate(close = 100*(close - first(close))/first(close)) %>% ggplot(aes(date, close, color=symbol)) + geom_line()
```

Next, we aggregate the semiconductor stocks into a single portfolio with a combined rate of return.

```{r}
# Aggregation function using tq_portfolio() for monthly returns
aggregate_portfolio_monthly_returns = stock_returns_monthly %>% tq_portfolio(assets_col = symbol, returns_col = `MonthlyReturns`, weights = weights1, col_rename = "AggregateMonthlyReturns")

### Transforms data into percentages ###
aggregate_returns_monthly_percentages = data.frame("date" = aggregate_portfolio_monthly_returns$date, "AggregatePercentReturns" = aggregate_portfolio_monthly_returns$AggregateMonthlyReturns * 100)

aggregate_portfolio_monthly_returns
aggregate_returns_monthly_percentages
```

The historical aggregate returns for our equally weighted tech portfolio is displayed below along with a trend line to track long term direction.

```{r}
aggregate_portfolio_monthly_returns %>% ggplot(aes(x = date, y = `AggregateMonthlyReturns`)) + geom_point() + labs(title = "Pearl Fund Portfolio Returns", subtitle = "20% AMD, 20% INTC,20% NVDA, 20% QCOM, and 20% TSM", caption = "Shows an above-zero trend indicating long-term positive returns", x = "", y = "Monthly Returns") + 
  geom_smooth(method = "loess") + 
  theme_tq() + scale_color_tq() + scale_y_continuous(labels = scales::percent)
```

You can also find the performance growth our portfolio over the 20 year timeline below along with a trend line to track general shape & direction.

```{r}
aggregate_portfolio_monthly_returns_growth <- stock_returns_monthly %>%
    tq_portfolio(assets_col = symbol, 
                 returns_col= `MonthlyReturns`, 
                 weights = weights1,
                 col_rename   = "investment.growth",
                 wealth.index = TRUE) %>%
    mutate(investment.growth = investment.growth * 10000)

aggregate_portfolio_monthly_returns_growth %>%
    ggplot(aes(x = date, y = investment.growth)) +
    geom_line(linewidth = 2, color = palette_light()[[1]]) +
    labs(title = "Pearl Fund Portfolio Growth",
         subtitle = "20% AMD, 20% INTC,20% NVDA, 20% QCOM, and 20% TSM",
         caption = "Performance growth over our 20-year horizon",
         x = "Year", y = "Portfolio Value") +
    geom_smooth(method = "loess") +
    scale_y_continuous(labels = scales::dollar)
```

Now we move on with combining the returns of the the two baseline index funds with the returns of our tech portfolio. A graph is also displayed to represent the returns of all three funds together in one frame.

```{r}

# Portfolio + S&P500 Table
spy_combined_table_of_returns = left_join(aggregate_portfolio_monthly_returns, spy_returns_monthly, by="date")

# Portfolio + NASDAQ Table
nasdaq_combined_table_of_returns = left_join(aggregate_portfolio_monthly_returns, nasdaq_returns_monthly, by="date")

spy_combined_table_of_returns
nasdaq_combined_table_of_returns
```

```{r}
# Combined Table (3 Funds)
three_fund_combined_table_of_returns = left_join(spy_combined_table_of_returns, nasdaq_returns_monthly, by="date")

three_fund_combined_table_of_returns
```

```{r}
three_fund_long = three_fund_combined_table_of_returns |> 
  pivot_longer(cols = 2:4, values_to = "return", names_to = "symbol") |>
  arrange(symbol)

three_fund_long |>
  ggplot(aes(x = date, y = return, color = symbol)) +
  geom_line() +
  facet_grid(symbol ~ .)
```

Finally, we compute several important CAPM statistical & financial measures for our portfolio relative to the performance of each respective benchmark index we have chosen.

```{r}

### Useful Measures: table.Stats, table.CAPM, table.AnnualizedReturns, table.Correlation, table.DownsideRisk, table.DownsideRiskRatio, table.HigherMoments, table.InformationRatio, table.Variability, VaR, SharpeRatio ###

# Pear Fund vs. SPY
statisticsA = spy_combined_table_of_returns %>% tq_performance(Ra = `AggregateMonthlyReturns`, Rb = `SPYMonthlyReturns`, performance_fun = table.CAPM)

# Pearl Fund vs. NASDAQ
statisticsB = nasdaq_combined_table_of_returns %>% tq_performance(Ra = `AggregateMonthlyReturns`, Rb = `NASDAQMonthlyReturns`, performance_fun = table.CAPM)

statisticsA
statisticsB
```

------------------------------------------------------------------------

| ***Analysis & Commentary on the above metrics...***

------------------------------------------------------------------------

We extend this analysis to comparing multiple portfolios (with different asset weightings) against our benchmark indices. We utilize the mapping technique to achieve this. To begin, we extend our original returns table by creating an identical copy of our monthly historical returns to test our second portfolio. Notice how we now have our portfolio labeled by an index to distinguish.

```{r}
multiple_stock_returns_monthly <- stock_returns_monthly %>% tq_repeat_df(n = 2)
multiple_stock_returns_monthly
```

We now form a combined vector called *weights* which concatenates both our portfolio desired weights together.

```{r}
# Combined Vector of Weights
weights <- c(
    weights1,
    weights2
)

# Connecting our vector of weights with the relevant stocks and portfolio index
portfolio_of_weights <- tibble(stock_tickers) %>% tq_repeat_df(n = 2) %>% bind_cols(tibble(weights)) %>% group_by(portfolio)

portfolio_of_weights
```

As usual, we now leverage the "*tq_portfolio()"* function to aggregate our returns for each of our portfolios.

```{r}
multiple_portfolio_returns_monthly <- multiple_stock_returns_monthly %>%
    tq_portfolio(assets_col  = symbol, 
                 returns_col = `MonthlyReturns`, 
                 weights     = portfolio_of_weights, 
                 col_rename  = "MultiplePortfolioMonthlyReturns")

multiple_portfolio_returns_monthly$portfolio = as.character(multiple_portfolio_returns_monthly$portfolio)

multiple_portfolio_returns_monthly
```

You can visualize the portfolio returns below

```{r}
multiple_portfolio_returns_monthly |>
ggplot(aes(x = date, y = MultiplePortfolioMonthlyReturns, color = portfolio)) +
  geom_line() +
  facet_grid(portfolio ~ .)
```

Finally to prepare for statistical metrics tests, we join the returns of the S&P 500 index with our portfolio returns — you can see the monthly returns side by side, indexed by each portfolio below.

```{r}

combined_benchmark_multiple_portfolio <- left_join(multiple_portfolio_returns_monthly, 
                                     spy_returns_monthly,
                                     by = "date")
combined_benchmark_multiple_portfolio
```

Voila! You can find the relevant Capital Asset Pricing Model (CAPM) statistics for each portfolio (performance tested against the SPY benchmark index).

::: {.callout-tip appearance="simple"}
**Once again we will refer to these useful metrics:**

table.Stats, table.CAPM, table.AnnualizedReturns, table.Correlation, table.DownsideRisk, table.DownsideRiskRatio, table.HigherMoments, table.InformationRatio, table.Variability, VaR, SharpeRatio
:::

```{r}
combined_benchmark_multiple_portfolio %>%
    tq_performance(Ra = MultiplePortfolioMonthlyReturns, Rb = `SPYMonthlyReturns`, performance_fun = table.CAPM)
```

A similar metrics table is shown below for the relevant Sharpe Ratio tests for our two portfolios.

```{r}
combined_benchmark_multiple_portfolio %>%
    tq_performance(Ra = MultiplePortfolioMonthlyReturns, Rb = NULL, performance_fun = SharpeRatio)
```

------------------------------------------------------------------------

> ***Analysis & Commentary on the above metrics...***

------------------------------------------------------------------------

These foundational analysis and statistical metrics will now help us as we move on to portfolio optimization. Drawing from the principles of Modern Portfolio Theory (MPT), we aim to optimize for the portfolio of assets which under a mean-variance form analysis, maximizes expected returns for a given level of risk-tolerance (standard deviation). We will be making use of concepts such as the efficient frontier model, efficient set mathematics, etc...

```{r}

Stock_Statistics = stock_returns_monthly %>% group_by(symbol)  %>% summarise(Historic_Expected_Returns = mean(`MonthlyReturns`), Standard_Deviation = sd(`MonthlyReturns`), Variance = VAR(`MonthlyReturns`), Count = n())
Stock_Statistics 
```

The following are excess returns with respect to the treasury yields (useful later on for the SharpeRatio)

```{r}
Expected_Treasury_Excess_Return = Stock_Statistics$Historic_Expected_Returns - ((1 + latest_ten_year_treasury_yield/100)^(1/12) - 1)

Expected_Treasury_Excess_Return
```

We append this to our table of statistics for future use.

```{r}
Stock_Statistics = mutate(Stock_Statistics, Expected_Treasury_Excess_Return = Expected_Treasury_Excess_Return)

Stock_Statistics
```

Now we calculate a different type of excess returns, where we subtract our expected monhtly return value from each of our historical monthly return values, to get an array of excess returns. This is common practice in a lot of risk-adjusted return portfolio analysis.

```{r}
excess_returns_table <- stock_returns_monthly %>% left_join(Stock_Statistics, by = "symbol") %>% mutate(Excess_Returns = `MonthlyReturns` - Historic_Expected_Returns)

excess_returns_table <- returns_table %>% select(`symbol`, `date`, `Excess_Returns`)
excess_returns_table
```

In this step we are calculating two crucial matrices that are relevant for our optimization, the variance-covariance matrix and the correlation matrix. Each value of each matrix follows from the following equations, respectively:

> \*Note that the correlation matrix necessitates an input of the Var-CoVar Matrix

$$
Var-CoVar: \Sigma = \frac{X^T X}{n-1}
$$

$$
Corr: \frac{\Sigma}{\sigma^T \sigma}
$$

```{r}
excess_returns_wider =  excess_returns_table |> pivot_wider(names_from = symbol, values_from = Excess_Returns)

M = as.matrix(excess_returns_wider[ ,2:6])

# Variance-Covariance Matrix
var(M)

#Correlation Matrix
cor(M)
```

Now we begin optimization under various different selected constraints which are adjustable depending on one's objectives.
