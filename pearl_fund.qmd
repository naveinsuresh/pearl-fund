---
title: "Pearl Fund"
author: "Navein Suresh, Suryaveer Singh"
date: Sys.Date()
format: html
editor: visual
---

# Overview

In this project, our primary goal is to enhance the risk-adjusted returns of a carefully curated portfolio of stocks. The focus of our analysis is on a select 5-stock portfolio, nicknamed â€” "Pearl Fund." This portfolio comprises leading semiconductor companies in the market, namely:

1.  Advanced Micro Devices, Inc. (NASDAQ: AMD)
2.  Intel Corp. (NASDAQ: INTC)
3.  NVIDIA Corp. (NASDAQ: NVDA)
4.  QUALCOMM Inc. (NASDAQ: QCOM)
5.  Taiwan Semiconductor Manufacturing Co. Ltd. (NYSE: TSM)

Our approach involves the utilization of sophisticated financial models, which will be thoroughly explained later in this documentation. Furthermore, we leverage the power of various statistical and financial packages. We use th R programming language as our preferred tool for seamless portfolio optimization. Through a comprehensive analysis of historical data, we aim to evaluate and compare the performance of our portfolio against two benchmark index fundsâ€”S&P 500 and NASDAQ.

Before proceeding, ensure that the following libraries are installed and imported for seamless execution of the project:

```         
```

```{r}
library(tidyverse) # Convenient data tables + processing
library(ggplot2) # Visualization tools
library(knitr) # Report rendering
library(tidyquant) # Financial data and statistical metrics
library(quantmod) # Similar to tidyquant features
library(PerformanceAnalytics) # Econometric Tools for Performance and Risk Analysis
library(PortfolioAnalytics) # Optimization statsitical metrics
library(DEoptim) # Optimization solver
library(ROI) # Optimization 
library(tseries) # Time Series Analysis & Computational Finance
library(TTR) # Technical Trading Rules 
library(fPortfolio) # Portfolio Selection and Optimization
# library(pander) # An R 'Pandoc' Writer 
require(ROI.plugin.glpk)
require(ROI.plugin.quadprog)
```

## Equity Analysis

Our analysis spans from January 1, 2004, until the latest market day close, providing a comprehensive view of various economic scenarios, including critical events such as the global financial crisis of 2008 and the SARS COVID-19 epidemic in 2020. We use the FRED economic data set to retrieve the most recent 10-year Treasury yields for our statistical testing we will run later.

```{r}
stock_tickers <- c("AMD", "INTC", "NVDA", "QCOM", "TSM")

# Treasury Yields (FRED)
ten_year_treasury_yield_table = arrange(tq_get("DGS10", get = "economic.data"), desc(date))
latest_ten_year_treasury_yield = slice(ten_year_treasury_yield_table, 1)$price

cat("Latest 10-year Treasury Yield: ",latest_ten_year_treasury_yield,"%")
```

### **Monthly Returns (Table View)**

We proceed to collect our monthly stock returns using the tidyquant functions. After some data pre-processing, we display the 5 most recent monthly returns for each of our stocks.

\# Displays the most recent 5 monthly stock returns

```{r}
# Raw Stock Monthly Returns
stock_returns_monthly_raw <- tq_get(stock_tickers, get  = "stock.prices", from = "2004-01-01", to = Sys.Date())

# Transformed Monthly Stock Returns (long format)
stock_returns_monthly_long = stock_returns_monthly_raw %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturns")

# Transformed Monthly Stock Returns (wide format)
stock_returns_monthly_wide = pivot_wider(stock_returns_monthly_long, names_from=symbol, values_from=MonthlyReturns)

# Displays the most recent 5 monthly stock returns
stock_returns_monthly_wide_decreasing =  stock_returns_monthly_wide[order(stock_returns_monthly_wide$date, decreasing = TRUE), ]
head(stock_returns_monthly_wide_decreasing, 5)
```

### **Stock Growth & Monthly Returns (Graph View)**

Displayed below is a graphical representation of the total returns (%) for our chosen stocks covering the chosen time period. To facilitate accurate time series analysis, the data has been standardized.

```{r}
stock_returns_monthly_raw1 <- stock_returns_monthly_raw %>% 
  group_by(symbol) %>% 
  mutate(return = 100 * (log(close) - log(first(close))) / log(first(close))) %>% 
  ggplot(aes(date, return, color = symbol)) + 
  geom_line() +
  labs(title = "Stock Performance Over Time Period",
       y = "Return (%) on a log scale") +
  theme_minimal()
stock_returns_monthly_raw1
```

Furthermore, within the same temporal framework, we present the monthly returns for our selected stocks. The graphical representation highlights the varying levels of volatility, with more erratic and spread-out patterns evident in stocks characterized by higher volatility.

```{r}
stock_returns_monthly_long %>% ggplot(aes(date, `MonthlyReturns`, color=symbol)) + 
  geom_line() +
  facet_wrap(~ symbol)
```

### Statistical Metrics

We calculate the expected returns (based off historical returns), standard deviations, variance, and total count for each of our assets.

```{r}
Stock_Statistics = stock_returns_monthly_long %>% group_by(symbol)  %>% summarise(Historic_Expected_Returns = mean(`MonthlyReturns`), Standard_Deviation = sd(`MonthlyReturns`), Variance = VAR(`MonthlyReturns`), Count = n())
Stock_Statistics 
```

```{r}
ggplot(Stock_Statistics, aes(x = Standard_Deviation, y = Historic_Expected_Returns, color = symbol)) +
geom_point(size = 5) +
# Miscellaneous Formatting
theme_bw() + ggtitle(" Monthly Historic Risk-Return Tradeoff") +
xlab("Volatility") + ylab("Expected Returns")
```

#### **Calculation of Excess Returns**

Moving forward, our analysis involves the computation of excess returns. This is achieved by subtracting our anticipated monthly return value from each historical monthly return value, resulting in an array of excess returns. This practice is widely adopted in risk-adjusted portfolio analysis to refine the assessment of portfolio performance.

We need to split the data into 2 - 2004 to 2019 and 2019 to 2024. calculate mean return from 04 to 19 and then apply it to 19 to 24 excess return calculation.

```{r}
excess_returns_table <- stock_returns_monthly_long %>% left_join(Stock_Statistics, by = "symbol") %>% mutate(Excess_Returns = `MonthlyReturns` - Historic_Expected_Returns)

excess_returns_table <- excess_returns_table %>% select(`symbol`, `date`, `Excess_Returns`)

# Displays the most recent 5 monthly excess stock returns
excess_returns_table_decreasing =  excess_returns_table[order(excess_returns_table$date, decreasing = TRUE), ]
head(excess_returns_table_decreasing,5)
```

## Splitting data into two 

We need to split the data into 2 - 2004 to 2019 and 2019 to 2024. calculate mean return from 04 to 19 and then apply it to 19 to 24 excess return calculation.

```{r}
stock_returns_monthly_raw0419 <- tq_get(stock_tickers, get  = "stock.prices", from = "2004-01-01", to = Sys.Date() - 1825)

# Transformed Monthly Stock Returns (long format)
stock_returns_monthly_long0419 = stock_returns_monthly_raw0419 %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturns")
stock_returns_monthly_long0419

stock_returns_monthly_raw2024 <- tq_get(stock_tickers, get  = "stock.prices", from = Sys.Date() - 1825, to = Sys.Date())
stock_returns_monthly_long2024 = stock_returns_monthly_raw2024 %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturns")
stock_returns_monthly_long2024

```

We compute two matrices essential for our optimization process: the variance-covariance matrix and the correlation matrix. Each value within these matrices is derived from the following respective equations:

::: callout-note
ðŸ’¡ Calculation of the correlation matrix necessitates the input of the variance-covariance matrix
:::

$$
Var-CoVar: \Sigma = \frac{X^T X}{n-1}
$$

$$
Corr: \frac{\Sigma}{\sigma^T \sigma}
$$

```{r}
excess_returns_wider =  excess_returns_table |> pivot_wider(names_from = symbol, values_from = Excess_Returns)

M = as.matrix(excess_returns_wider[ ,2:6])

# Variance-Covariance Matrix
cat("Variance-Covariance Matrix")
cat("\n")
var(M)
cat("\n")

#Correlation Matrix
cat("Correlation Matrix")
cat("\n")
d = cor(M)
cat("\n")

#Correlation Matrix with percentage 
cat("Correlation Matrix as percentages")
cat("\n")
cor(M) * 100

```

Upon acquiring the historical monthly stock returns for our designated time frame, our focus shifts to the evaluation of the two ETFs of the comparison benchmark index fundsâ€”SPDR S&P 500 ETF Trust (NYSE: SPY) and NASDAQ COMPOSITE (NYSE: QQQ).

**S&P 500 (Monthly % Returns):**

```{r}
# Raw S&P 500 Monthly Returns
spy_returns_monthly_raw <- tq_get("SPY", get = "stock.prices", from = "2004-01-01", to = "2024-01-01")

# Transformed S&P 500 Monthly Returns
spy_returns_monthly = tq_transmute(spy_returns_monthly_raw, select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "SPYMonthlyReturns")

### Transforms data into percentages ###
spy_returns_monthly_percentages = data.frame("date" = spy_returns_monthly$date, "SPYPercentReturns" = spy_returns_monthly$SPYMonthlyReturns * 100)

# Displays the most recent 5 monthly SPY returns (%)
spy_returns_monthly_percentages_decreasing =  spy_returns_monthly_percentages[order(spy_returns_monthly_percentages$date, decreasing = TRUE), ]

head(spy_returns_monthly_percentages_decreasing[, c("date", "SPYPercentReturns")], 5)
```

**NASDAQ (Monthly % Returns)::**

```{r}
# Raw NASDAQ Monthly Returns
nasdaq_returns_monthly_raw <- tq_get("QQQ", get = "stock.prices", from = "2004-01-01", to = "2024-01-01")

# Transformed NASDAQ Monthly Returns
nasdaq_returns_monthly = tq_transmute(nasdaq_returns_monthly_raw, select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "NASDAQMonthlyReturns")

### Transforms data into percentages ###
nasdaq_returns_monthly_percentages = data.frame("date" = nasdaq_returns_monthly$date, "NASDAQPercentReturns" = nasdaq_returns_monthly$NASDAQMonthlyReturns * 100)

# Displays the most recent 5 monthly NASDAQ returns (%)
nasdaq_returns_monthly_percentages_decreasing =  nasdaq_returns_monthly_percentages[order(nasdaq_returns_monthly_percentages$date, decreasing = TRUE), ]

head(nasdaq_returns_monthly_percentages_decreasing[, c("date", "NASDAQPercentReturns")], 5)
```

The line graph below illustrates the price trends over our time period for the benchmark returns â€” SPY and QQQ. As before, we standardize the index prices to facilitate a more effective comparison.

```{r}
# Combining benchmark raw dataframes
benchmark_returns_raw = rbind(spy_returns_monthly_raw, nasdaq_returns_monthly_raw)

benchmark_returns_raw %>% group_by(symbol) %>% mutate(close = 100*(close - first(close))/first(close)) %>% ggplot(aes(date, close, color=symbol)) + geom_line()
```

Now, we proceed to consolidate the returns of the two baseline index funds into a unified table. Additionally, a graph is presented to visually depict the combined returns of the two benchmarks within a single frame.

```{r}
benchmark_combined_table_of_returns = left_join(spy_returns_monthly, nasdaq_returns_monthly, by="date")

benchmark_long = benchmark_combined_table_of_returns |> 
  pivot_longer(cols = 2:3, values_to = "return", names_to = "symbol") |>
  arrange(symbol)

benchmark_long |>
  ggplot(aes(x = date, y = return, color = symbol)) +
  geom_line() +
  facet_grid(symbol ~ .)
```

------------------------------------------------------------------------

| ...

------------------------------------------------------------------------

## Portfolio Optimization

The groundwork laid by our analysis and statistical metrics sets the stage for the upcoming portfolio optimization process. Drawing inspiration from the tenets of Modern Portfolio Theory (MPT), our objective is to optimize the portfolio of assets. Employing a mean-variance framework analysis, we seek to maximize expected returns for a specified level of risk tolerance, represented by standard deviation. Our approach involves leveraging concepts such as the efficient set mathematics, efficient frontier model, and other relevant methodologies.

#### Equally Weighted Portfolio Initialization

```{r}
init_weights = rep(0.2, 5)
assets = setNames(init_weights, stock_tickers)
assets
```

Next, using our optimization libraries we create a portfolio object where we will input our asset, initialized weights, portfolio constraints, and our objectives. Our desired outcome will be a vector of weights which optimizes for our objectives under our desired constraints.

/

```{r}
pearlfund = portfolio.spec(assets = assets)
print(pearlfund)

# CONSTRAINTS

pearlfund = add.constraint(portfolio=pearlfund, type="weight_sum", min_sum=1, max_sum=1)
pearlfund <- add.constraint(portfolio=pearlfund, type="leverage", min_sum=0.99, max_sum=1.01)
pearlfund <- add.constraint(portfolio=pearlfund, type="box", min=0.00, max=1.00)
pearlfund = add.constraint(portfolio=pearlfund, type="return", return_target=0.0353)

# OBJECTIVES

# pearlfund = add.objective(portfolio=pearlfund, type='return', name='mean')
#pearlfund = add.objective(portfolio = pearlfund, type='risk', name="var", risk_aversion=7)
pearlfund = add.objective(pearlfund, type = "risk", name = "StdDev")

# OPTIMIZE.PORTFOLIO

opt_maxret <- optimize.portfolio(R=stock_returns_monthly_wide, portfolio=pearlfund, optimize_method="ROI", trace=TRUE)

# OPTIMAL WEIGHTS

print(opt_maxret)

# VISUALIZATIONS

plot(opt_maxret, risk.col="StdDev", return.col="mean", main="Maximum Return Optimization", chart.assets=TRUE, xlim=c(0, 0.18), ylim=c(0,0.04))
```

The following code extracts the weights from our portfolio object and stores it as a vector of weights.

```{r}
optimized_list_of_weights = opt_maxret[1]$weights
optimized_vector_of_weights = unlist(optimized_list_of_weights)
optimized_vector_of_weights
```

### Optimized Portfolio Visualizations

#### Fund Total Growth Return

The following visual displays how much you would have right now if you had invested \$10,000 at the start of the time period till today.

> \*Please note that this does not account for tax consequences, which could reduce your final capital depending on tax policy and brackets

```{r}
aggregate_portfolio_monthly_returns <- stock_returns_monthly_long %>%
    tq_portfolio(assets_col = symbol, 
                 returns_col= `MonthlyReturns`, 
                 weights = optimized_vector_of_weights,
                 col_rename   = "investment.growth",
                 wealth.index = TRUE) %>% 
  mutate(investment.growth = investment.growth * 10000)

aggregate_portfolio_monthly_returns %>%
    ggplot(aes(x = date, y = investment.growth)) +
    geom_line(linewidth = 2, color = palette_light()[[1]]) +
    labs(title = "Pearl Fund Portfolio Growth",
         subtitle = "Optimized Portfolio Growth",
         caption = "Performance growth over our 20-year horizon",
         x = "Year", y = "Portfolio Value") +
    geom_smooth(method = "loess") +
    scale_y_continuous(labels = scales::dollar)
```

#### Fund Monthly Returns

The following visual displays a scatter plot of the monthly returns throughout the time period of interest. A trend line (using "loess") is fitted onto the graph to display the variation and direction at different regions of the scatter plot.

```{r}
aggregate_portfolio_monthly_returns = stock_returns_monthly_long %>% tq_portfolio(assets_col = symbol, returns_col = `MonthlyReturns`, weights = optimized_vector_of_weights, col_rename = "AggregateMonthlyReturns")

aggregate_portfolio_monthly_returns %>% ggplot(aes(x = date, y = `AggregateMonthlyReturns`)) + geom_point() + labs(title = "Pearl Fund Portfolio Returns", subtitle = "Optimized Portfolio", caption = "Shows an above-zero trend indicating long-term positive returns", x = "", y = "Monthly Returns") + 
  geom_smooth(method = "loess") + 
  theme_tq() + scale_color_tq() + scale_y_continuous(labels = scales::percent)
```

#### Annualized Returns

To get a better appreciation for the fund's return, we proceed to annualize the the monthly returns.

```{r}
portfolio_monthly_mean = unname(unlist(opt_maxret[2]$objective_measures$mean))

# Convert to annualized % return
annualized_return <- paste0(100*((1 + portfolio_monthly_mean)^12 - 1), "%")
names(annualized_return) = "Annualized Return"

cat("Annualized Return:", annualized_return)
```

## Comparitive Statistical Analysis

To objectively test our portfolio, we will be calculating several financial metrics in relation to both our benchmarks â€” SPY & QQQ.

Valuable tq_performance tests...

:   table.Stats, table.CAPM, table.AnnualizedReturns, table.Correlation, table.DownsideRisk, table.DownsideRiskRatio, table.HigherMoments, table.InformationRatio, table.Variability, VaR, SharpeRatio

To begin, it is important to combine the benchmark index monthly returns with our portfolio monthly returns.

```{r}
# Portfolio + S&P500 Table
spy_combined_table_of_returns = left_join(aggregate_portfolio_monthly_returns, spy_returns_monthly, by="date")

# Portfolio + NASDAQ Table
nasdaq_combined_table_of_returns = left_join(aggregate_portfolio_monthly_returns, nasdaq_returns_monthly, by="date")

# Displays the most recent 5 monthly returns for the tables above
spy_combined_table_of_returns_decreasing =  spy_combined_table_of_returns[order(spy_combined_table_of_returns$date, decreasing = TRUE), ]
head(spy_combined_table_of_returns_decreasing, 5)

nasdaq_combined_table_of_returns_decreasing =  nasdaq_combined_table_of_returns[order(nasdaq_combined_table_of_returns$date, decreasing = TRUE), ]
head(nasdaq_combined_table_of_returns_decreasing, 5)
```

The following code combines all the funds of interest that intend to be comparing into a single table (wide format).

```{r}
# Combined Table (3 Funds)
three_fund_combined_table_of_returns = left_join(spy_combined_table_of_returns, nasdaq_returns_monthly, by="date")

three_fund_combined_table_of_returns
```

This is a great display of a side by side view of the monthly returns for our three funds of comparison for our time period of interest.

```{r}
three_fund_long = three_fund_combined_table_of_returns |> 
  pivot_longer(cols = 2:4, values_to = "return", names_to = "symbol") |>
  arrange(symbol)

three_fund_long |>
  ggplot(aes(x = date, y = return, color = symbol)) +
  geom_line() +
  facet_grid(symbol ~ .)
```

The tq_performance function in tidyquant allows us to produce statistical metrics for financial analysis for our Peal Fund against each of the benchmark index funds.

```{r}
# Pear Fund vs. SPY
statisticsA = spy_combined_table_of_returns %>% tq_performance(Ra = `AggregateMonthlyReturns`, Rb = `SPYMonthlyReturns`, performance_fun = table.CAPM)

# Pearl Fund vs. NASDAQ
statisticsB = nasdaq_combined_table_of_returns %>% tq_performance(Ra = `AggregateMonthlyReturns`, Rb = `NASDAQMonthlyReturns`, performance_fun = table.CAPM)

statisticsA
statisticsB
```

# Efficient Frontier

Okay, so I worked on 2 different approaches to the efficient frontier. I'll give more info below

This line of code below is essential as it eliminates the date column and only considers returns.

```{r}
stock_returns_monthly_wide[, -1]
```

## Approach 1

This is the first approach (<https://rforanalytics.com/01-Part_2_portfolio.html>). The code is completely from this site, I just tweaked the variable names. Still not entirely sure what this spits out and how we calculate the optimal portfolio from this

```{r}
np1 = 1000
ret2 = stock_returns_monthly_wide[, -1]  #excluding dates
mu1 = colMeans(ret2)  #mean returns
na1 = ncol(ret2)  #number of assets
varc1 = cov(ret2)

riskp1 = NULL  #vector to store risk
retp1 = NULL  #vector to store returns
# using loops here (not aiming for efficiency but demonstration)

for (i in 1:np1) {
    w = diff(c(0, sort(runif(na1 - 1)), 1))  # random weights
    r1 = t(w) %*% mu1  #matrix multiplication
    sd1 = t(w) %*% varc1 %*% w
    retp1 = rbind(retp1, r1)
    riskp1 = rbind(riskp1, sd1)
}

# create a data frame of risk and return
d_p1 = data.frame(Ret = retp1, Risk = riskp1)
# simple plot
plot(d_p1$Risk, d_p1$Ret, xlab = "Risk", ylab = "Return", main = "Frontier Portfolios",
    col = "blue")
```

```{r}
# Set confidence level
confidence_level <- 0.95

# Calculate the index corresponding to the confidence level
n <- nrow(d_p1)
tail_index <- floor((1 - confidence_level) * n)

# Sort portfolio returns in descending order
sorted_returns <- sort(retp1, decreasing = TRUE)

# Extract the tail returns
tail_returns <- sorted_returns[1:tail_index]

# Calculate Expected Tail Loss (CVaR)
cvar <- mean(tail_returns)

# Print the result
cat("Expected Tail Loss (CVaR) at", confidence_level * 100, "% confidence level:", cvar, "\n")

```

```{r}
# Set confidence level
confidence_level <- 0.95

# Number of iterations

# Initialize vector to store CVaR values
cvar_values <- numeric(np1)

# Loop for generating CVaR values
for (i in 1:np1) {
  # Generate a random sample of portfolio returns
  random_sample <- sample(retp1, n, replace = TRUE)
  
  # Sort the random sample in descending order
  sorted_returns <- sort(random_sample, decreasing = TRUE)
  
  # Calculate the index corresponding to the confidence level
  tail_index <- floor((1 - confidence_level) * n)
  
  # Extract the tail returns
  tail_returns <- sorted_returns[1:tail_index]
  
  # Calculate Expected Tail Loss (CVaR)
  cvar_values[i] <- mean(tail_returns)
}

# Print the first few CVaR values
length(cvar_values)
```

```{r}
# Add ETL to this table
d_p1 = mutate(d_p1, ETL = cvar_values)
print(d_p1)
```

```{r}
p1 = ggplot(d_p1, aes(ETL, Ret, colour = Ret))
# scatter plot
p1 = p1 + geom_point()
# scatter plot with density and identified port risk return (highest
# lowest returns and min risk)
p1 + geom_point() + geom_hline(yintercept = c(max(d_p1$Ret), median(d_p1$Ret),
    min(d_p1$Ret)), colour = c("darkgreen", "darkgray", "darkred"), size = 1) +
    geom_vline(xintercept = d_p1[(d_p1$Risk == min(d_p1$Risk)), ][, 2]) +
    labs(colour = "Portfolio Return", x = "Expected Tail Loss", y = "Portfolio Return",
        title = "Random Feasible Portfolios") + theme_bw()
```

```{r}
p1 = ggplot(d_p1, aes(Risk, Ret, colour = Ret))
# scatter plot
p1 = p1 + geom_point()
# scatter plot with density and identified port risk return (highest
# lowest returns and min risk)
p1 + geom_point() + geom_hline(yintercept = c(max(d_p1$Ret), median(d_p1$Ret),
    min(d_p1$Ret)), colour = c("darkgreen", "darkgray", "darkred"), size = 1) +
    geom_vline(xintercept = d_p1[(d_p1$Risk == min(d_p1$Risk)), ][, 2]) +
    labs(colour = "Portfolio Return", x = "Portfolio Risk", y = "Portfolio Return",
        title = "Random Feasible Portfolios") + theme_bw()
```

## Approach 2

This one seems a little easier. <https://www.youtube.com/watch?v=pchqBhof62U> I am not entirely sure how we give it the optimized weights we calculate.

```{r}
return.matrix = as.timeSeries(stock_returns_monthly_wide[, -1])
# return.matrix
print(dim(return.matrix))
```

```{r}
efficient.frontier = portfolioFrontier(return.matrix, `setRiskFreeRate<-`(portfolioSpec(), (latest_ten_year_treasury_yield/100)/12), constraints = "LongOnly" )
plot(efficient.frontier, c(1,7))

# Syntax for choosing vector in plot function above ^b
# 1. Efficient Frontier 
# 2. Global Minimum Variance Portfolio 
# 3. Tangent (optimal) portfolio 
# 4. Risk/Return of each asset 
# 5. Equal Weights Portfolio
# 6. Two Asset frontier 
# 7. Monte Carlo 
# 8. Sharpe Ratio 
```

```{r}
weightsPlot(efficient.frontier)
```

**How to Read Graph Above:**

-   Pick a vertical line/column at a specified target return and target risk and you can find out the allocations of stocks in your portfolio (through the lengths of the appropriate colored bars) to achieve those metrics.

Pick your desired

```{r}
library(PortfolioAnalytics)
# initialise with asset names uses time series data
data_p2 = zoo(ret1[, -1], order.by = as.Date(ret1$Date))
# create specification
port = portfolio.spec(assets = c(colnames(data_p2)))
# add long only constraint
port = add.constraint(portfolio = port, type = "long_only")
# add full investment contraint
port = add.constraint(portfolio = port, type = "full_investment")

# objective: manimise risk
port_rnd = add.objective(portfolio = port, type = "risk", name = "StdDev")

# objective: maximise return
port_rnd = add.objective(portfolio = port_rnd, type = "return", name = "mean")

# 1. optimise random portfolios

rand_p = optimize.portfolio(R = data_p2, portfolio = port_rnd, optimize_method = "random",
    trace = TRUE, search_size = 1000)
# plot

chart.RiskReward(rand_p, risk.col = "StdDev", return.col = "mean", chart.assets = TRUE)  #also plots the equally weighted portfolio
```

### Multiple Portfolio Testing

We can optimize for different constraints and objectives to produce different weights and compare multiple portfolios side by side like above.
