---
title: "Pearl Fund: Portfolio Anlaysis & Optmization"
author: "Navein Suresh & Suryaveer Singh"
date: "`r format(Sys.Date(), '%d %B, %Y')`"
editor: visual
toc: True
highlight-style: pygments
format:
  html: 
    code-fold: true
    html-math-method: katex
  pdf:
    geometry: 
      - top=30mm
      - left=30mm
---

# Overview

In this project, our primary goal is to enhance the risk-adjusted returns of a carefully curated portfolio of stocks. The focus of our analysis is on a equity/fixed income portfolio, nicknamed â€” "Pearl Fund." This portfolio comprises Stocks & ETFs from a diverse array of industries and asset classes, namely:

1.  Chevron Corporation (NYSE: CVX)
2.  Costco Wholesale Corporation (NASDAQ: COST)
3.  Ford Motor Company (NYSE: F)
4.  HP Inc. (NYSE: HPQ)
5.  Johnson & Johnson (NYSE: JNJ)
6.  JPMorgan Chase & Co. (NYSE: JPM)
7.  Microsoft Corporation (NASDAQ: MSFT)
8.  PepsiCo, Inc. (NASDAQ: PEP)
9.  Procter & Gamble Company (NYSE: PG)
10. Raytheon Technologies Corporation (NYSE: RTX)
11. iShares 20+ Year Treasury Bond ETF (NASDAQ: TLT)

Our approach involves the utilization of sophisticated financial models, which will be thoroughly explained later in this documentation. Furthermore, we leverage the power of various statistical and financial packages. We use th R programming language as our preferred tool for seamless portfolio optimization. Through a comprehensive analysis of historical data, we aim to evaluate and compare the performance of our portfolio against two benchmark index fundsâ€”S&P 500 and NASDAQ.

::: callout-tip
ðŸ’¡ Detailed Background Overview: [Pearl Fund](https://drive.google.com/file/d/1xbmX7GZ3pakPfEb3VJlRCiLe_34yudnt/view?usp=sharing)
:::

Once you're familiarized with the code, feel free to explore and add your own curated collections of assets to see how they perform! To this make sure to enter the *exchange traded ticker symbols* to the *stock_tickers* vector in the second cell below. You must ensure that the assets you choose were traded on an exchange from a minimum of 2004 onward.

Before proceeding, ensure that the following libraries are installed and imported for seamless execution of the project:

```{r}
suppressWarnings(suppressPackageStartupMessages({
  library(tidyverse)
  library(ggplot2)
  library(plotly)
  library(knitr)
  library(tidyquant)
  library(corrplot)
  library(quantmod)
  library(gganimate)
  library(PerformanceAnalytics)
  library(PortfolioAnalytics)
  library(DEoptim)
  library(ROI)
  library(tseries)
  library(TTR)
  library(fPortfolio)
  require(ROI.plugin.glpk)
  require(ROI.plugin.quadprog)
}))

```

# Equity Analysis

Our analysis spans from January 1, 2004, until the latest market day close, providing a comprehensive view of various economic scenarios, including critical events such as the global financial crisis of 2008 and the SARS COVID-19 epidemic in 2020. We use the FRED economic data set to retrieve the most recent 10-year Treasury yields for our statistical testing we will run later.

```{r}
stock_tickers <- c("TLT", "MSFT", "HPQ", "COST", "F", "PEP", "JPM", "RTX", "PG", "CVX", "JNJ")

# Treasury Yields (FRED)
ten_year_treasury_yield_table = arrange(tq_get("DGS10", get = "economic.data"), desc(date))
latest_ten_year_treasury_yield = slice(ten_year_treasury_yield_table, 1)$price

cat("Latest 10-year Treasury Yield: ",latest_ten_year_treasury_yield,"%")
```

## Monthly Returns (Table View)

We proceed to collect our monthly stock returns using the tidyquant functions. We split this data set into two sets, one set ranging from 2004 to 5 years prior to the current date and another one from the previous 5 years. After some data pre-processing, we display the 5 most recent monthly returns for each of our stocks for the entire timeline below.

```{r}

stock_returns_monthly_full_raw <- tq_get(stock_tickers, get  = "stock.prices", from = "2004-01-01", to = Sys.Date())

# Transformed Monthly Stock Returns (long format)
stock_returns_monthly_full_long = stock_returns_monthly_full_raw %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturnsFull")

# Transformed Monthly Stock Returns (wide format)
stock_returns_monthly_full_wide = pivot_wider(stock_returns_monthly_full_long, names_from=symbol, values_from=MonthlyReturnsFull)

# Displays the most recent 5 monthly stock returns
stock_returns_monthly_full_wide_decreasing =  stock_returns_monthly_full_wide[order(stock_returns_monthly_full_wide$date, decreasing = TRUE), ]
as.data.frame(head(stock_returns_monthly_full_wide_decreasing, 5))

```

The data set below shows the last 5 monthly returns from 2004 to 5 years prior to today's date.

```{r}
# Raw Stock Monthly Returns
stock_returns_monthly_raw <- tq_get(stock_tickers, get  = "stock.prices", from = "2004-01-01", to = Sys.Date() - 1815)

# Transformed Monthly Stock Returns (long format)
stock_returns_monthly_long = stock_returns_monthly_raw %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturns")

# Transformed Monthly Stock Returns (wide format)
stock_returns_monthly_wide = pivot_wider(stock_returns_monthly_long, names_from=symbol, values_from=MonthlyReturns)

# Displays the most recent 5 monthly stock returns
stock_returns_monthly_wide_decreasing =  stock_returns_monthly_wide[order(stock_returns_monthly_wide$date, decreasing = TRUE), ]
as.data.frame(head(stock_returns_monthly_wide_decreasing, 5))
```

We repeat the above process for the 2nd batch of monthly stock returns which lasts for the last 5 years.

```{r}
stock_returns_monthly_test_raw <- tq_get(stock_tickers, get  = "stock.prices", from = Sys.Date() - 1815, to = Sys.Date())

stock_returns_monthly_test_long = stock_returns_monthly_test_raw %>% group_by(symbol) %>% tq_transmute(select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "MonthlyReturns2nd")

stock_returns_monthly_test_wide = pivot_wider(stock_returns_monthly_test_long, names_from=symbol, values_from=MonthlyReturns2nd)

stock_returns_monthly_test_wide_decreasing =  stock_returns_monthly_test_wide[order(stock_returns_monthly_test_wide$date, decreasing = TRUE), ]
as.data.frame(head(stock_returns_monthly_test_wide_decreasing, 5))
```

## **Stock Growth & Monthly Returns (Graph View)**

Displayed below is a graphical representation of the total returns (%) for our chosen stocks covering the chosen time period. To facilitate accurate time series analysis, the data has been standardized.

```{r}
stock_returns_monthly_raw1 <- stock_returns_monthly_raw %>% 
  group_by(symbol) %>% 
  mutate(return = 100 * (close - first(close)) / first(close)) %>% 
  ggplot(aes(date, return, color = symbol)) + 
  geom_line() +
  labs(title = "Stock Performance Over Time Period",
       y = "Return (%)") +
  theme_minimal()
stock_returns_monthly_raw1
```

The individual graphs below show the total return (to date) for each asset on their own scales.

```{r}
stock_returns_monthly_raw %>% 
  group_by(symbol) %>% 
  mutate(return = 100 * (close - first(close)) / first(close)) %>% 
  ggplot(aes(date, return, color = symbol)) + 
  geom_line() +
  labs(title = "Stock Performance Over Time Period",
       y = "Return (%) on a log scale") +
  theme_minimal() +
  facet_wrap(~symbol, scales = "free_y")
```

Furthermore, within the same temporal framework, we present the monthly returns for our selected stocks. The graphical representation highlights the varying levels of volatility, with more erratic and spread-out patterns evident in stocks characterized by higher volatility.

```{r}
stock_returns_monthly_long %>% ggplot(aes(date, `MonthlyReturns`, color=symbol)) + 
  geom_line() +
  facet_wrap(~ symbol)
```

## Statistical Metrics

We calculate the expected returns (based off historical returns), standard deviations, variance, and total count for each of our assets.

```{r}
Stock_Statistics = stock_returns_monthly_long %>% group_by(symbol)  %>% summarise(Historic_Expected_Returns = mean(`MonthlyReturns`), Standard_Deviation = sd(`MonthlyReturns`), Variance = VAR(`MonthlyReturns`), Count = n())
Stock_Statistics 
```

```{r}
animation1 = ggplot(Stock_Statistics, aes(x = Standard_Deviation, y = Historic_Expected_Returns, color = symbol)) +
geom_point(size = 5) +
theme_bw() + ggtitle(" Monthly Historic Risk-Return Tradeoff") +
xlab("Volatility") + ylab("Expected Returns")

ggplotly(animation1)
```

**Calculation of Excess Returns**

Moving forward, our analysis involves the computation of excess returns. This is achieved by subtracting our anticipated monthly return value from each historical monthly return value, resulting in an array of excess returns. This practice is widely adopted in risk-adjusted portfolio analysis to refine the assessment of portfolio performance.

Using our split data set, we calculate the historical expected mean from the first group and our excess returns using the monthly returns from the last 5 years with respect to the calculated expected returns to ensure the excess returns don't contain future data priced in.

```{r}
excess_returns_table <- stock_returns_monthly_test_long %>% left_join(Stock_Statistics, by = "symbol") %>% mutate(Excess_Returns = `MonthlyReturns2nd` - Historic_Expected_Returns)

excess_returns_table <- excess_returns_table %>% select(`symbol`, `date`, `Excess_Returns`)

# Displays the most recent 5 monthly excess stock returns
excess_returns_table_decreasing =  excess_returns_table[order(excess_returns_table$date, decreasing = TRUE), ]
head(excess_returns_table_decreasing,length(stock_tickers))
```

We compute two matrices essential for our optimization process: the variance-covariance matrix and the correlation matrix. Each value within these matrices is derived from the following respective equations:

::: callout-note
ðŸ’¡ Calculation of the correlation matrix necessitates the input of the variance-covariance matrix
:::

$$
Var-CoVar: \Sigma = \frac{X^T X}{n-1}
$$

$$
Corr: \frac{\Sigma}{\sigma^T \sigma}
$$

```{r}
excess_returns_wider =  excess_returns_table |> pivot_wider(names_from = symbol, values_from = Excess_Returns)

M = as.matrix(excess_returns_wider[ ,2:12])

# Variance-Covariance Matrix
cat("Variance-Covariance Matrix")
cat("\n")
round(var(M), 4)
cat("\n")

cor_mat = cor(M)

# Correlation Matrix with percentage 
cat("Correlation Matrix as percentages")
cat("\n")
round(cor_mat * 100, 3)

```

We run a *Principal Component Analysis* calculation to display the groupings and correlations among the various assets in the pearl fund. The graph below displays the groups of closely related or correlated associations with certain stocks. The horizontal axis (Comp.1) and the vertical axis (Comp.2) represent the first two principal components derived from the PCA. These are the two dimensions that capture the most variance in the data set. From an investment standpoint, this plot might help in understanding which stocks move together (correlated), and potentially, it might help in identifying which stocks contribute most to the variance in the portfolio. This could be used for risk management and diversification; for instance, once might choose to invest in stocks that are less correlated with each other according to the PCA results. For example, the biplot shows that **`TLT`**, which is an ETF that tracks long-term treasury bonds, has a very different loading compared to other assets, indicating that its price movements are likely less correlated with those of the stocks.

```{r}
pca = princomp(cor_mat, cor = TRUE)
pca_df = as.data.frame(cor(cor_mat, pca$scores))

suppressWarnings(suppressPackageStartupMessages({pca_df |>
  ggplot(aes(x = Comp.1, y = Comp.2)) +
  geom_point(alpha = 0.3) +
  geom_text(label = rownames(pca_df)) + 
  geom_vline(xintercept = 0) +
  geom_hline(yintercept = 0) +
  scale_x_continuous(limits = c(-1,1)) +
  scale_y_continuous(limits = c(-1,1)) +

  # Adding arrows from origin to points
  geom_segment(aes(x = 0, y = 0, 
                   xend = Comp.1, yend = Comp.2),
               arrow = arrow(length = unit(0.05, "inches")),
               color = "blue", 
               data = subset(pca_df, rownames(pca_df) %in% c("TLT", "MSFT", "HPQ", "COST", "F", "PEP", "JPM", "RTX", "PG", "CVX", "JNJ")),  # Add ticker symbols here
               size = 0.5, 
               lineend = "round")}))

```

The following visuals will help aid the user with further understanding the correlations between the certain assets and larger groupings. Below we include a correlogram & a heat-map. The correlogram displays the correlations of various stock pairs on a grid to display the direction (blue shows + and red shows -) and the intensity (increasing size/shade of dot shows a value closer to a magnitude of 1). A white box shows a correlation of 0, ruling out a linear association.

```{r}
corrplot(cor_mat, method = "circle")
```

The dendrogram below shows another display of correlation pairings as well as clustering of certain groups of assets to show similarities/relatedness.

```{r}
heatmap(cor_mat)
```

# Benchmark Performance

Upon acquiring the historical monthly stock returns for our designated time frame, our focus shifts to the evaluation of the two ETFs of the comparison benchmark index fundsâ€”SPDR S&P 500 ETF Trust (NYSE: SPY) and NASDAQ COMPOSITE (NYSE: QQQ). We display the 5 most recent SPY & NASDAQ Monthly returns available.

**S&P 500 (Monthly % Returns):**

```{r}
# Raw S&P 500 Monthly Returns
spy_returns_monthly_raw <- tq_get("SPY", get = "stock.prices", from = "2004-01-01", to = "2024-01-01")

# Transformed S&P 500 Monthly Returns
spy_returns_monthly = tq_transmute(spy_returns_monthly_raw, select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "SPYMonthlyReturns")

# Transforms data into percentages 
spy_returns_monthly_percentages = data.frame("date" = spy_returns_monthly$date, "SPYPercentReturns" = spy_returns_monthly$SPYMonthlyReturns * 100)

# Displays the most recent 5 monthly SPY returns (%)
spy_returns_monthly_percentages_decreasing =  spy_returns_monthly_percentages[order(spy_returns_monthly_percentages$date, decreasing = TRUE), ]

head(spy_returns_monthly_percentages_decreasing[, c("date", "SPYPercentReturns")], 5)
```

**NASDAQ (Monthly % Returns):**

```{r}
# Raw NASDAQ Monthly Returns
nasdaq_returns_monthly_raw <- tq_get("QQQ", get = "stock.prices", from = "2004-01-01", to = "2024-01-01")

# Transformed NASDAQ Monthly Returns
nasdaq_returns_monthly = tq_transmute(nasdaq_returns_monthly_raw, select = adjusted, mutate_fun = periodReturn, period = "monthly", col_rename = "NASDAQMonthlyReturns")

# Transforms data into percentages 
nasdaq_returns_monthly_percentages = data.frame("date" = nasdaq_returns_monthly$date, "NASDAQPercentReturns" = nasdaq_returns_monthly$NASDAQMonthlyReturns * 100)

# Displays the most recent 5 monthly NASDAQ returns (%)
nasdaq_returns_monthly_percentages_decreasing =  nasdaq_returns_monthly_percentages[order(nasdaq_returns_monthly_percentages$date, decreasing = TRUE), ]

head(nasdaq_returns_monthly_percentages_decreasing[, c("date", "NASDAQPercentReturns")], 5)
```

The line graph below illustrates the price trends over our time period for the benchmark returns â€” SPY and QQQ. As before, we standardize the index prices to facilitate a more effective comparison.

```{r}
# Combining benchmark raw dataframes
benchmark_returns_raw = rbind(spy_returns_monthly_raw, nasdaq_returns_monthly_raw)

benchmark_returns_raw %>% group_by(symbol) %>% mutate(close = 100*(close - first(close))/first(close)) %>% ggplot(aes(date, close, color=symbol)) + geom_line()
```

Now, we proceed to consolidate the returns of the two baseline index funds into a unified table. Additionally, a graph is presented to visually depict the combined returns of the two benchmarks within a single frame.

```{r}
benchmark_combined_table_of_returns = left_join(spy_returns_monthly, nasdaq_returns_monthly, by="date")

benchmark_long = benchmark_combined_table_of_returns |> 
  pivot_longer(cols = 2:3, values_to = "return", names_to = "symbol") |>
  arrange(symbol)

benchmark_long |>
  ggplot(aes(x = date, y = return, color = symbol)) +
  geom_line() +
  facet_grid(symbol ~ .)
```

------------------------------------------------------------------------

# Portfolio Optimization

The groundwork laid by our analysis and statistical metrics sets the stage for the upcoming portfolio optimization process. Drawing inspiration from the tenets of Modern Portfolio Theory (MPT), our objective is to optimize the portfolio of assets. Employing a mean-variance framework analysis, we seek to maximize expected returns for a specified level of risk tolerance, represented by standard deviation. We will also be utilizing other constraints and objectives to customize what we aim with our financial returns. Our approach involves leveraging concepts such as the efficient set mathematics, efficient frontier model, and other relevant methodologies.

**Equally Weighted Portfolio Initialization**

```{r}
init_weights = rep((1/length(stock_tickers)), length(stock_tickers))
assets = setNames(init_weights, stock_tickers)
assets
```

Next, using our optimization libraries we create a portfolio object where we will input our asset, initialized weights, portfolio constraints, and our objectives. Our desired outcome will be a vector of weights which optimizes for our objectives under our desired constraints.

*Comments on Constraints*

1.  Weight Sum -\> sets a range of values for the total weight of out portfolio assets
2.  Leverage -\> sets a range of values to depict additional borrowing
3.  Box -\> sets a range of values for which the assets can be weighted at
4.  Return -\> sets a target return rate for our portfolio to achieve

*Comments on Objectives*

1.  Return -\> aims to create a portfolio to maximize the return
2.  Risk Aversion Parameter -\> sets the level of risk aversion for the optimization. A higher risk aversion value indicates a greater emphasis on minimizing risk in the portfolio.
3.  Risk -\> aims to create a portfolio which minimizes the risk (StdDev, var, etc..)

```{r}
pearlfund = portfolio.spec(assets = assets)
print(pearlfund)

# CONSTRAINTS

pearlfund = add.constraint(portfolio=pearlfund, type="weight_sum", min_sum=1, max_sum=1)
# pearlfund <- add.constraint(portfolio=pearlfund, type="leverage", min_sum=0.99, max_sum=1.01)
pearlfund <- add.constraint(portfolio=pearlfund, type="box", min=0.00, max=1)
# pearlfund = add.constraint(portfolio=pearlfund, type="return", return_target=0.0150)

# OBJECTIVES

pearlfund = add.objective(portfolio=pearlfund, type='return', name='mean')
pearlfund = add.objective(portfolio = pearlfund, type='risk', name="var", risk_aversion=7)
# pearlfund = add.objective(pearlfund, type = "risk", name = "StdDev")

# OPTIMIZE.PORTFOLIO

opt_maxret <- optimize.portfolio(R=stock_returns_monthly_full_wide, portfolio=pearlfund, optimize_method="ROI", trace=TRUE)

# OPTIMAL WEIGHTS

print(opt_maxret)

# VISUALIZATIONS

plot(opt_maxret, risk.col="StdDev", return.col="mean", main="Maximum Return Optimization", chart.assets=TRUE, xlim=c(0, 0.18), ylim=c(0,0.04))
```

Our visual above displays a line graph of the associated weights of our assets and a scatter plot comparing the mean vs. StdDev of the individual portfolio compared to the mean vs. StdDev of the portfolio as an aggregate whole.

The following code extracts the weights from our portfolio object and stores it as a vector of weights.

```{r}
optimized_list_of_weights = opt_maxret[1]$weights
optimized_vector_of_weights = unlist(optimized_list_of_weights)
optimized_vector_of_weights
```

## Optimized Portfolio Visualizations

### Fund Total Growth Return

The visual below displays how much you would have right now if you had invested \$10,000 at the start of the time period till today.

> \*Please note that this does not account for tax consequences, which could reduce your final capital depending on tax policy and brackets

```{r}
# Data Retstructuring

# Pearl Fund

aggregate_portfolio_monthly_returns_growth <- stock_returns_monthly_long %>%
    tq_portfolio(assets_col = symbol, 
                 returns_col= `MonthlyReturns`, 
                 weights = optimized_vector_of_weights,
                 col_rename   = "investment.growth",
                 wealth.index = TRUE) %>% 
  mutate(investment.growth = investment.growth * 10000)

# Pearl Fund - Equally Weighted 

equally_weighted_portfolio_monthly_returns_growth <- stock_returns_monthly_long %>%
    tq_portfolio(assets_col = symbol, 
                 returns_col= `MonthlyReturns`, 
                 weights = init_weights,
                 col_rename   = "investment.growth",
                 wealth.index = TRUE) %>% 
  mutate(investment.growth = investment.growth * 10000)

# SPY Portfolio

vals1 <- rep("SPY", 240)
spy_returns_monthly_ticker = spy_returns_monthly
spy_returns_monthly_ticker$symbol <- vals1

spy_returns_monthly_ticker_growth <- spy_returns_monthly_ticker %>%
    tq_portfolio(assets_col = symbol, 
                 returns_col= `SPYMonthlyReturns`, 
                 weights = c(1),
                 col_rename   = "investment.growth",
                 wealth.index = TRUE) %>% 
  mutate(investment.growth = investment.growth * 10000)

# NASDAQ Portfolio

vals2 = rep("NASDAQ", 240)
nasdaq_returns_monthly_ticker = nasdaq_returns_monthly
nasdaq_returns_monthly_ticker$symbol <- vals2

nasdaq_returns_monthly_ticker_growth <- nasdaq_returns_monthly_ticker %>%
    tq_portfolio(assets_col = symbol, 
                 returns_col= `NASDAQMonthlyReturns`, 
                 weights = c(1),
                 col_rename   = "investment.growth",
                 wealth.index = TRUE) %>% 
  mutate(investment.growth = investment.growth * 10000)

# Pearl Fund Portfolio Growth
ggplot(aggregate_portfolio_monthly_returns_growth, aes(x = date, y = investment.growth)) +
  geom_line(linewidth = 2, color = "red") +
  geom_smooth(method = "loess") +
  labs(title = "Pearl Fund Portfolio Growth",
       subtitle = "Optimized Portfolio Growth",
       caption = "Performance growth over our 20-year horizon",
       x = "Year", y = "Portfolio Value") +
  scale_y_continuous(labels = scales::dollar)

# SPY Portfolio Growth
ggplot(spy_returns_monthly_ticker_growth, aes(x = date, y = investment.growth)) +
  geom_line(linewidth = 2, color = "blue") +
  geom_smooth(method = "loess") +
  labs(title = "SPY Portfolio Growth",
       subtitle = "Portfolio Growth",
       caption = "Performance growth over our 20-year horizon",
       x = "Year", y = "Portfolio Value") +
  scale_y_continuous(labels = scales::dollar)

# NASDAQ Portfolio Growth
ggplot(nasdaq_returns_monthly_ticker_growth, aes(x = date, y = investment.growth)) +
  geom_line(linewidth = 2, color = "green") +
  geom_smooth(method = "loess") +
  labs(title = "NASDAQ Portfolio Growth",
       subtitle = "Portfolio Growth",
       caption = "Performance growth over our 20-year horizon",
       x = "Year", y = "Portfolio Value") +
  scale_y_continuous(labels = scales::dollar)
```

### Fund Monthly Returns

The following visual displays a scatter plot of the monthly returns throughout the time period of interest. A trend line (using "loess") is fitted onto the graph to display the variation and direction at different regions of the scatter plot.

```{r}
aggregate_portfolio_monthly_returns = stock_returns_monthly_long %>% tq_portfolio(assets_col = symbol, returns_col = `MonthlyReturns`, weights = optimized_vector_of_weights, col_rename = "AggregateMonthlyReturns")

aggregate_portfolio_monthly_returns %>% ggplot(aes(x = date, y = `AggregateMonthlyReturns`)) + geom_point() + labs(title = "Pearl Fund Portfolio Returns", subtitle = "Optimized Portfolio", caption = "Shows an above-zero trend indicating long-term positive returns", x = "", y = "Monthly Returns") + 
  geom_smooth(method = "loess") + 
  theme_tq() + scale_color_tq() + scale_y_continuous(labels = scales::percent)
```

### Annualized Returns

To get a better appreciation for the fund's return, we proceed to annualize the the monthly returns.

```{r}
portfolio_monthly_mean = unname(unlist(opt_maxret[2]$objective_measures$mean))

# Convert to annualized % return
annualized_return <- paste0(100*((1 + portfolio_monthly_mean)^12 - 1), "%")
names(annualized_return) = "Annualized Return"

cat("Annualized Return:", annualized_return)
```

# Comparative Statistical Analysis

To objectively test our portfolio, we will be calculating several financial metrics in relation to both our benchmarks â€” SPY & QQQ.

Valuable tq_performance tests...

:   *table.Stats, table.CAPM, table.AnnualizedReturns, table.Correlation, table.DownsideRisk, table.DownsideRiskRatio, table.HigherMoments, table.InformationRatio, table.Variability, VaR, SharpeRatio*

To begin, it is important to combine the benchmark index monthly returns with our portfolio monthly returns.

```{r}
# Portfolio + S&P500 Table
spy_combined_table_of_returns = left_join(aggregate_portfolio_monthly_returns, spy_returns_monthly, by="date")

# Portfolio + NASDAQ Table
nasdaq_combined_table_of_returns = left_join(aggregate_portfolio_monthly_returns, nasdaq_returns_monthly, by="date")

# Displays the most recent 5 monthly returns for the tables above
spy_combined_table_of_returns_decreasing =  spy_combined_table_of_returns[order(spy_combined_table_of_returns$date, decreasing = TRUE), ]
head(spy_combined_table_of_returns_decreasing, 5)

nasdaq_combined_table_of_returns_decreasing =  nasdaq_combined_table_of_returns[order(nasdaq_combined_table_of_returns$date, decreasing = TRUE), ]
head(nasdaq_combined_table_of_returns_decreasing, 5)
```

The following code combines all the funds of interest that intend to be comparing into a single table (wide format) once again with the 5 most recent returns displayed.

```{r}
# Combined Table (3 Funds)
three_fund_combined_table_of_returns = left_join(spy_combined_table_of_returns, nasdaq_returns_monthly, by="date")

three_fund_combined_table_of_returns_decreasing <- arrange(three_fund_combined_table_of_returns, desc(date))

head(three_fund_combined_table_of_returns_decreasing, 5)
```

This is a great display of a side by side view of the monthly returns for our three funds of comparison for our time period of interest. The following visuals are a great measure of the overall volatility of our portfolio compared to the two benchmarks. Graphs that display more "ups" and "downs" with monthly returns indicate larger deviations from the mean. Given similar annualized returns and expected long term value, a risk-averse investor should prefer the portfolios/funds which minimize the volatility/risk for the given time period.

```{r}
three_fund_long = three_fund_combined_table_of_returns |> 
  pivot_longer(cols = 2:4, values_to = "return", names_to = "symbol") |>
  arrange(symbol)

three_fund_long |>
  ggplot(aes(x = date, y = return, color = symbol)) +
  geom_line() +
  facet_grid(symbol ~ .)
```

The tq_performance function in tidyquant allows us to produce statistical metrics for financial analysis for our Peal Fund against each of the benchmark index funds.

```{r}
# Pearl Fund vs. SPY
statisticsA = spy_combined_table_of_returns %>% tq_performance(Ra = `AggregateMonthlyReturns`, Rb = `SPYMonthlyReturns`, performance_fun = table.CAPM)

# Pearl Fund vs. NASDAQ
statisticsB = nasdaq_combined_table_of_returns %>% tq_performance(Ra = `AggregateMonthlyReturns`, Rb = `NASDAQMonthlyReturns`, performance_fun = table.CAPM)

as.data.frame(statisticsA)
as.data.frame(statisticsB)
```

------------------------------------------------------------------------

# Mean-Variance Analysis (Efficient Frontier)

The efficient frontier is a concept in financial portfolio theory that represents the set of optimal portfolios that offer the highest expected return for a given level of risk, or the lowest risk for a given level of expected return. It is useful for investors and portfolio managers as it helps identify the optimal balance between risk and return, enabling them to construct portfolios that maximize potential gains while minimizing exposure to volatility.

To apply this framework to our portfolio, we first need to modify our monthly stock returns table so that the date column is removed with once again the 5 most recent returns displayed.

```{r}
stock_returns_monthly_wide_dateless = stock_returns_monthly_wide[, -1]

stock_returns_monthly_wide_decreasing <- arrange(stock_returns_monthly_wide, desc(date))

head(stock_returns_monthly_wide_decreasing[, -1], 5)
```

The next step is to simulate, using a loop, a series of random weights which we then apply certain matrices to. The result is a data frame which stores the list of returns and risk values for portfolios of different weights.

```{r}
np1 = 1000
ret2 = stock_returns_monthly_wide_dateless  #excluding dates
mu1 = colMeans(ret2)  #mean returns
na1 = ncol(ret2)  #number of assets
varc1 = cov(ret2)

riskp1 = NULL  #vector to store risk
retp1 = NULL  #vector to store returns
# using loops here (not aiming for efficiency but demonstration)

for (i in 1:np1) {
    w = diff(c(0, sort(runif(na1 - 1)), 1))  # random weights
    r1 = t(w) %*% mu1  #matrix multiplication
    sd1 = t(w) %*% varc1 %*% w
    retp1 = rbind(retp1, r1)
    riskp1 = rbind(riskp1, sd1)
}

# create a data frame of risk and return
d_p1 = data.frame(Ret = retp1, Risk = riskp1)
```

We use ggplot to and to visualize the data accordingly and as expected we achieve the curve as derived from the Modern Portfolio Framework.

```{r}

p1 = ggplot(d_p1, aes(Risk, Ret, colour = Ret))
# scatter plot
p1 = p1 + geom_point()
# scatter plot with density and identified port risk return (highest
# lowest returns and min risk)
p1 + geom_point() + geom_hline(yintercept = c(max(d_p1$Ret), median(d_p1$Ret),
    min(d_p1$Ret)), colour = c("darkgreen", "darkgray", "darkred"), size = 1) +
    geom_vline(xintercept = d_p1[(d_p1$Risk == min(d_p1$Risk)), ][, 2]) +
    labs(colour = "Portfolio Return", x = "Portfolio Risk", y = "Portfolio Return",
        title = "Random Feasible Portfolios") + theme_bw()

```

Here is another display of our plot using a different R frontier calculation package. To choose what you'd like to plot exactly in plot(), enter values from below as a vector:

> *Syntax for choosing vector in plot function below:*
>
> 1.  Efficient Frontier
> 2.  Global Minimum Variance Portfolio
> 3.  Tangent (optimal portfolio)
> 4.  Risk/Return of each asset
> 5.  Equal Weights Portfolio
> 6.  Two Asset Frontier
> 7.  Monte Carlo
> 8.  Sharpe Ratio

```{r}

return.matrix = as.timeSeries(stock_returns_monthly_wide[, -1])

efficient.frontier = portfolioFrontier(return.matrix, `setRiskFreeRate<-`(portfolioSpec(), (latest_ten_year_treasury_yield/100)/12), constraints = "LongOnly" )

plot(efficient.frontier, c(1, 3, 7))
plot(efficient.frontier, c(1,3,5,7))


```

Optimal portfolios for a given target risk are displayed by the dark colored dots on the border or *frontier* of the Monte-Carlo simulated data points. The capital allocation line (blue line) which intersects the efficient frontier at a point of tangency indicating the *optimal portfolio* for an investor at the current risk-free rate (10 year yield on government bond).

The following visual is another very useful metric to understand portfolio weightings based on chosen return/risk levels.

> **Interpretation**
>
> *Pick a vertical line/column at a specified target return and target risk and you can find out the allocations of stocks in your portfolio (through the lengths of the appropriate colored bars) to achieve those chosen metrics.*

```{r}
weightsPlot(efficient.frontier)
```

Here our goal is to produce a different type of frontier visual. Instead of plotting the traditional measures of risk (standard deviation or variance) against returns, we turn to a different measure of risk â€” *expected tail loss (ETL).* ETL is a another measure of risk which could be a better use in portfolio optimization in certain situations.

> ETL, also known as conditional value at risk (CVaR), is a risk measure that quantifies the expected loss in the tail of a distribution of possible outcomes beyond a certain confidence level. ETL focuses specifically on the extreme or tail events, giving an indication of the potential loss in those extreme scenarios. The preference for ETL over variance in some cases arises because ETL puts more emphasis on extreme events, which can be crucial in risk assessment. Variance might not adequately capture the potential impact of rare but severe events, whereas ETL provides a clearer picture of the expected loss in the tail of the distribution.

The following code generates a series of ETL values for each of our portfolio weights at a chosen confidence level (95%).

```{r}

confidence_level <- 0.95
np1 <- length(retp1)
cvar_values <- numeric(np1)
returns <- rnorm(1000, mean(retp1), mean(riskp1))
etl_values <- numeric(np1)

for (i in 1:np1) {
  random_sample <- sample(returns, length(returns), replace = TRUE)
  sorted_returns <- sort(random_sample, decreasing = TRUE)
  tail_index <- floor((1 - confidence_level) * length(returns))
  tail_returns <- sorted_returns[1:tail_index]
  etl_values[i] <- mean(tail_returns)
}
```

We add these ETL values to our data frame of Returns and Risk for our various portfolios.

```{r}
# Add ETL to this table
d_p1 = mutate(d_p1, ETL = etl_values)
head(d_p1)
```

Finally, we plot these ETL values against our return values for our portfolios and are able to visualize the results. By plotting ETL vs. Expected Return, you can assess whether the expected returns of the portfolio adequately compensates for the potential magnitude of extreme losses.

```{r}
p1 <- ggplot(d_p1, aes(ETL, Ret, colour = Ret)) +
  geom_point() +
  geom_hline(yintercept = c(max(d_p1$Ret), median(d_p1$Ret), min(d_p1$Ret)),
             colour = c("darkgreen", "darkgray", "darkred"), size = 1) +
  geom_vline(xintercept = d_p1[(d_p1$Risk == min(d_p1$Risk)), ][, 2]) +
  labs(colour = "Portfolio Return",
       x = "Expected Tail Loss",
       y = "Portfolio Return",
       title = "Random Feasible Portfolios") +
  theme_bw()

p1 + xlim(min(d_p1$ETL), max(d_p1$ETL)) + ylim(min(d_p1$Ret), max(d_p1$Ret))
```

------------------------------------------------------------------------

# Conclusion

To conclude, we plot the Optimized Pearl Fund Portfolio (in red) versus the Equally Weighted Pearl Fund Portfolio (in blue). As evident in the graph below, the Optimized Portfolio generates higher returns than the Equally Weighted Portfolio, while rising more steadily.

```{r}
ggplot() +
  geom_line(data = aggregate_portfolio_monthly_returns_growth, aes(x = date, y = investment.growth), 
            linewidth = 2, color = "red") +
  geom_smooth(data = aggregate_portfolio_monthly_returns_growth, aes(x = date, y = investment.growth), 
              method = "loess", color = "red", se = FALSE) +
  geom_line(data = equally_weighted_portfolio_monthly_returns_growth, aes(x = date, y = investment.growth), 
            linewidth = 2, color = "blue") +
  geom_smooth(data = equally_weighted_portfolio_monthly_returns_growth, aes(x = date, y = investment.growth), 
              method = "loess", color = "blue", se = FALSE) +
  labs(title = "Pearl Fund Optimized Portfolio Growth vs. Equally Weighted Portfolio",
       subtitle = ,
       caption = "Performance growth over our 20-year horizon",
       x = "Year", y = "Portfolio Value") +
  scale_y_continuous(labels = scales::dollar) +
 theme_minimal()

```
